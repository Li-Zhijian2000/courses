# 图论

```cpp
struct Edge {
    int u, v, w;
    Edge(int u, int v, int w): u(u), v(v), w(w) {}
    friend bool operator <(const Edge& a, const Edge& b) {
      return a.w < b.w;
    }
};
vector<Edge> edges;
vector<int> G[maxn];
int n, m;
```

## Kruskal

O(mlogm)

```cpp
/* 无向图的最小生成树
 * 伪代码：
 * 把所有边排序
 * 初始化 MST 为空
 * 初始化连通分量，使每个点各成一个独立的连通分量
 * for each e:
 *   if (e.u 和 e.v 不在同一个连通分量)
 *     把 e 加入 MST
 *     合并 e.u 和 e.v 的连通分量
 */
int r[maxm], p[maxn];
int find(int x) { return p[x] == x ? x : x = find(p[x]); }
long kruskal() {
  for (int i = 0; i < n; i++) p[i] = i;
  for (int i = 0; i < m; i++) r[i] = i;
  sort(r, r+m, [](const int a, const int b) { return edges[a] < edges[b]; });
  
  long ans = 0;
  for (int i = 0, j = 0; i < m; i++) {
    Edge& e = edges[r[i]];
    int x = find(e.u), y = find(e.v);
    if (x != y) {
      ans += e.w;
      p[x] = y;
      j++
    }
    if (j == n-1) {
      break;
    }
  }
  return ans;
}
```

## Dijkstra


O(n^2^) / O(mlogn)

稠密图：m = n^2^

已经访问完的节点的最短路已得到

只有可以松弛的边才需要加进待选边里（剪枝）
```cpp
/* 权为正的有向图/无向图的单源最短路径
 * 伪代码：
 * vis[i] 清为 0
 * d[0] = 0, d[i] = inf
 * 循环 n 次：
 *   在所有未访问过节点中，选出 d 值最小的结点 x
 *   标记访问 x
 *   d[y] = min{d[y], d[x] + w(x, y)}
 */
void AddEdge(int u, int v, int w) {
  edges.push_back(Edge(u, v, w));
  G[u].push_back(edges.size() - 1);
}
typedef pair<int, int> pii;
const int inf = 0x3f3f3f3f;
bool vis[maxn];
int d[maxn];
int pa[maxn];
void dijkstra(int s) {
    for (int i = 0; i < n; i++) {
      vis[i] = 0;
      d[i] = inf;
    }
    priority_queue<pii, vector<pii>, greater<pii>> pq;
    d[s] = 0;
    pq.push(pii(d[s], s));

    while (!pq.empty()) {
        pii top = pq.top();
        pq.pop();
        int u = top.second, w = top.first;
        if (vis[u]) continue;
        vis[u] = 1;
        for (int i = 0; i < G[u].size(); i++) {
            Edge& e = edges[G[u][i]];
            if (d[e.v] > d[e.u] + e.w) {
                d[e.v] = d[e.u] + e.w;
                pa[e.v] = e.u;
                pq.push(pii(d[e.v], e.v));
            }
        }
    }
}
```

## Floyd

```cpp
for (int k = 0; k < n; k++)
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
			// d[i][j] = d[i][j] || (d[i][k] && d[k][j]);
```



区间信息的维护和查询
==================

$Add(x, d): A_x+d$

$Query(L, R): A_L+A_L+1+\dots+A_R$


前缀和
-----
$O(n) + O(1)$

树状数组
-------
$O(logn) + O(logn)$

$C_i = A_{i-lowbit(i)+1}+\dots+A_i$

```cpp
int lowbit(int x) { return x & -x; }
int sum(int x) {
    int res;
    while (x > 0) {
        res += c[x];
        x -= lowbit(x);
    }
    return res;
}
void add(int x, int d) {
    while (x <= n) {
        c[x] += d;
        x += lowbit(x);
    }
}
```

范围最小值（Range minimum query, RMQ）问题
----------------------------------------
$Query(L, R): min\{A_L,A_L+1,\dots,A_R\}$

令 $d(i,j)$ 表示从 $i$ 开始的，长度为 $2^j$ 的一段元素中的最小值

$d(i, j) = min\{d(i, j-1), d(i+2^{j-1}, j-1)\}$

```cpp
void RMQ_init(const vector<int>& A) {
    for (int i = 0; i < A.size(); i++) d[i][0] = A[i];
    for (int j = 1; (1<<j) <= n; j++)
        for (int i = 0; i + (1<<j) - 1 < n; i++)
            d[i][j] = min(d[i][j-1], d[i+(1<<(j-1))][j-1]);
}
int RMQ(int l, int r) {
    int k = 0;
    while ((1<<(k+1)) <= r-k+1) k++;
    return min(d[l][k], d[r-(1<<k)+1][k]);
}
```

游程编码
-------
(a, b) 表示 b 个连续的 a

离散化
-----
将取值范围很大的 n 个数映射到 1~n

字符串算法
=========

Trie 树
------
```cpp
struct Trie {
    int ch[maxn][sigma_size];
    int val[maxn];
    int sz;

    Trie() {
        sz = 1;
        memset(ch[0], 0, sizeof(ch[0]));
    }
    int idx(char c) { return c - 'a'; }

    void insert(char* s, int v) {
        int u = 0, n = strlen(s);
        for (int i = 0; i < n; i++) {
            int c = idx(s[i]);
            if (!ch[u][c]) {
                memset(ch[sz], 0, sizeof(ch[sz]));
                val[sz] = 0;
                ch[u][c] = sz++;
            }
        }
        val[u] = v;
    }
};
```
KMP 算法
-------

后缀数组
-------

数论
===

Etatosthenes 筛法
-----------------
原始：对于不超过 n 的每个非负整数 p ，删除 $2p, 3p, 4p,\dots$
```cpp
memset(vis, 0, sizeof(vis));
for (int i = 2; i <= n; i++)
    for (int j = i*2, j <= n; j += i)
        vis[j] = 1;
```
改进：对于不超过 n 的每个非负素数 p ，删除 $p^2, p^2+p, p^2+2p,\dots$
```cpp
int m = sqrt(n + 0.5);
memset(vis, 0, sizeof(vis));
for (int i = 2; i <= m; i++) 
    if (!vis[i])
        for (int j = i*i; j <= n; j += i)
            vis[j] = 1;
```

排序与检索
===
二分查找
-------

归并排序
-------
```cpp
// A: 原数组
// T: 辅助数组
void merge_sort(int* A, int lo, int hi, int* T)
{
    if (hi - lo < 2) return;

    int mi = (lo + hi) / 2;
    merge_sort(A, lo, mi, T), merge_sort(A, mi, hi, T);

    int p = lo, q = mi, r = hi, i = lo;
    while (p < mi || q < hi) {
        if (q >= hi || p < mi && A[p] <= A[q])  T[i++] = A[p++];
        else T[i++] = A[q++];
        // else { T[i++] = A[q++]; res += mi - p; }
    }
    for (int i = lo; i < hi; i++) A[i] = T[i];
}
```

快速排序
-------
退化情况
- [x] * 输入序列已经有序  
- [ ] 输入序列含有大量重复元素
```cpp
// 勤于拓展，懒于交换
int partition(int* A, int lo, int hi) {
    swap(A[lo], A[lo + rand()%(hi - lo)]);
    int p = lo;
    while (lo < hi) {
        while (lo < hi && a[hi] >= a[p]) hi--;
        while (lo < hi && a[lo] <= a[p]) lo++;
        swap(a[lo], (lo != hi ? a[hi] : a[p]));
    }
    return lo;
}
// // 勤于交换，懒于拓展
// int partition(int* A, int lo, int hi) {
//     swap(A[lo], A[randint(lo, hi)]);
//     int p = A[lo];
//     while (lo < hi) {
//         while (lo < hi && a[hi] > p) hi--;
//         while (lo < hi && p < a[lo]) lo++;
//         swap(a[lo], (lo != hi ? a[hi] : p));
//         if (
//     }
//     return lo;
// }
void quick_sort(int* A, int lo, int hi) {
    if (hi - lo < 2) return;
    int mi = partition(A, lo, hi - 1);
    quick_sort(lo, mi), quick_sort(mi + 1, hi);
}
```
k-selection
-----------
```cpp
nth_element(a, a + (n-1)/2, a + n); // 选取中位左数
nth_element(a, a + n/2, a + n); // 选取中位右数
```









单调栈
=====
可以返回一个 vector ，第i个值是，原vector的第i个元素，至少向（左/右）走多少步，才能遇到一个（$</\le/\ge/>$）自己的元素


``` c++
template<class T, class BinaryPredicate>
pair<vector<T>, vector<T>> MonotoneStack(vector<T> input, const BinaryPredicate& p)
{
    if (p(0, 1)) 
        input.front() = input.back() = numeric_limits<T>::min();
    else input.front() = input.back() = numeric_limits<T>::max();

    pair<vector<T>, vector<T>> result;
    stack<T> s;
    
    for (int i = 0; i < input.size(); i++) {
        while (!s.empty() && p(input[i], input[s.top()]))
            s.pop();
        if (s.empty()) result.first.push_back(-1);
        else result.first.push_back(s.top());
        s.push(i);
    }

    while (!s.empty()) s.pop();

    for (int i = input.size(); i >= 0; i--) {
        while (!s.empty() && p(input[i], input[s.top()]))
            s.pop();
        if (s.empty()) result.second.push_back(-1);
        else result.second.push_back(s.top());
        s.push(i);        
    }

    return result;
}

```

```
>>> vector<long> input = {0, 10, 20, 30, 40, 50, 50, 30, 20, 10, 60, 0};

>>> auto res = MonotoneStack(input, less_equal<int>());
>>> res.first
[-1, 0, 1, 2, 3, 4, 4, 2, 1, 0, 9, -1]
>>> res.second
[-1, -1, 11, 11, 9, 8, 7, 7, 7, 8, 9, 11, -1]
```

动态规划
=======
DAG 上的动态规划
---------------
求最长路/最短路

```cpp

```

背包问题
-------
```cpp
const int maxn = 505;
const int maxm = 30005;
long cost[maxn], weight[maxn], cnt[maxn];
long dp[maxm];

struct Pack {
    long V;
    Pack(long v): V(v) {}
    void zero_one_pack(long cost, long weight) {
        for (int j = V; j >= cost; j--)
            dp[j] = max(dp[j], dp[j - cost] + weight);
    }
    void complete_pack(long cost, long weight) {
        for (int j = cost; j <= V; j++)
            dp[j] = max(dp[j], dp[j - cost] + weight);
    }
    void multiple_pack(long cost, long weight, long cnt) {
        if (cost * cnt >= V)
            complete_pack(cost, weight);
        else {
            long k = 1;
            while (k < cnt) {
                zero_one_pack(k * cost, k * weight);
                cnt -= k;
                k <<= 1;
            }
            zero_one_pack(cnt * cost, cnt * weight);
        }
    }
};
```

$$F[i,v] = max\{F[i-1,v], F[i-1,v-C_i]+W_i\}$$

$$F[i,v]=max\{F[i-1,v-kC_i]+kW_i|0\leq kC_i\leq v\}$$  
$$F[i,v]=max\{F[i-1,v], F[i,v-C_i]+W_i\}$$
### 无优化

``` c++
for (long i = 1; i <= n; i++) {
    for (long c = cost[i]; c <= m; c++) {
        dp[i][c] = max(dp[i-1][c], dp[i-1][c-cost[i]] + weight[i]);
    }
}
```

股票问题
-------
![](solution_p1.png)
```cpp
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + price[i]) // sell or rest
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - price[i]) // buy or rest

// base case:
// n days, piece[1..n]

dp[0][k][0] = 0;
dp[0][k][1] = -inf;
dp[i][0][0] = 0;
dp[i][0][1] = -inf
```
1. k = 1
   
   可以减少一维
   ```cpp
   dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + price[i]);
   dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - price[i]);
   
   dp[i][0] = max(dp[i-1][0], dp[i-1][1] + price[i]);
   dp[i][1] = max(dp[i-1][1], -price[i]);

   long dp_i_0 = 0, dp_i_1 = -inf;
   for (int i = 1; i <= n; i++) {
       dp_i_0 = max(dp_i_0, dp_i_1 + price[i]);
       dp_i_1 = max(dp_i_1, -price[i]);
   }
   ```
2. k = +inf
   
   此时 k = k - 1
   ```cpp
   dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + price[i]);
   dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k][0] - price[i])k;

   dp[i][0] = max(dp[i-1][0], dp[i-1][1] + price[i]);
   dp[i][1] = max(dp[i-1][1], dp[i-1][0] - price[i]);
   ```
3. k = +inf and buy and sell stock with cooldown
   
   ```cpp
   dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);
   dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i]);
   ```

```cpp
const int maxn = 1e3+5;
const int maxk = 1e3+5;
const long inf = 0x7f7f7f7f;
long price[maxn];
long dp[maxn][maxk][2];

struct Stock {
    int N, K;
    Stock(int n, int k): N(n), K(k) {}
    long k_1() {
        long k_i_0 = 0, k_i_1 = -inf;
        for (int i = 1; i <= N; i++) {
            k_i_0 = max(k_i_0, k_i_1 + price[i]);
            k_i_1 = max(k_i_1, -price[i]);
        }
        return k_i_0;
    }
    long k_inf() {
        long k_i_0 = 0, k_i_1 = -inf;
        for (int i = 1; i <= N; i++) {
            k_i_0 = max(k_i_0, k_i_1 + price[i]);
            k_i_1 = max(k_i_1, k_i_0 - price[i]);
        }
        return k_i_0;
    }
    long k_any() {
        if (K * 2 >= N) return k_inf();

        for (int k = 0; k <= K; k++)
            dp[0][k][1] = -inf;
        for (int i = 0; i <= N; i++)
            dp[i][0][1] = -inf;
        
        for (int i = 1; i <= N; i++)
            for (int k = 1; k <= K; k++) {
                dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + price[i]);
                dp[i][k][1] = max(dp[i-1][k][1], dp[i][k-1][0] - price[i]);
            }
        return dp[N][K][0];
    }
};
```

ALS
---

LCS
---
* 当 A[i] = B[j] 时，d(i, j) = d(i-1, j-1) + 1
* d(i, j) = max{d(i-1, j), d(i, j-1)}